package io.github.unattendedflight.fluent.i18n.compiler;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Map;

/**
 * Writes translation data to a custom binary format for faster loading
 * 
 * Binary format specification:
 * - Magic number: 4 bytes "FL18" (Fluent i18n)
 * - Version: 2 bytes (currently 1)
 * - Locale length: 2 bytes
 * - Locale string: variable length
 * - Entry count: 4 bytes
 * - For each entry:
 *   - Hash length: 2 bytes
 *   - Hash string: variable length
 *   - Translation length: 4 bytes
 *   - Translation string: variable length
 */
public class BinaryOutputWriter implements OutputWriter {
    /**
     * A magic byte sequence used as a file signature to identify binary output files
     * generated by the BinaryOutputWriter. This sequence serves as a specific marker
     * to ensure that the file is in the expected format.
     */
    private static final byte[] MAGIC = "FL18".getBytes();
    /**
     * Represents the version of the binary output format used by the {@code BinaryOutputWriter}.
     * This value is used to identify the format version during the writing and reading
     * of translation files to ensure compatibility.
     */
    private static final short VERSION = 1;
    /**
     * Specifies the byte order to be used when writing binary output.
     * This determines the endianness (LITTLE_ENDIAN or BIG_ENDIAN) of the data
     * written by the BinaryOutputWriter.
     */
    private static final ByteOrder BYTE_ORDER = ByteOrder.LITTLE_ENDIAN;
    
    /**
     * Configuration settings used to control compilation behavior.
     * This configuration is provided to the BinaryOutputWriter to dictate
     * how translation files should be processed and output.
     */
    private final CompilerConfig config;
    
    /**
     * Constructs a new BinaryOutputWriter instance with the specified compiler configuration.
     *
     * @param config the compiler configuration to be used for writing binary output
     */
    public BinaryOutputWriter(CompilerConfig config) {
        this.config = config;
    }
    
    /**
     * Writes the given translation data to a binary file format in the specified output directory.
     * This method handles creating the output directory if it does not exist and ensures the file contents
     * are formatted according to the binary output format specification.
     *
     * @param data the translation data containing entries and metadata
     * @param locale the locale string that specifies the language and region
     * @param outputDirectory the directory where the binary output file will be written
     * @return the path to the generated binary file
     * @throws IOException if an I/O error occurs during the writing process
     */
    @Override
    public Path write(TranslationData data, String locale, Path outputDirectory) throws IOException {
        Files.createDirectories(outputDirectory);
        Path outputFile = outputDirectory.resolve(OutputFormat.BINARY.getFileName(locale));
        
        try (FileChannel channel = FileChannel.open(outputFile, 
                StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {
            
            // Write header
            writeHeader(channel, locale);
            
            // Write entries
            writeEntries(channel, data);
        }
        
        return outputFile;
    }
    
    /**
     * Writes the file header to the specified file channel. The header includes a
     * magic number, version, and locale information in a binary format.
     *
     * @param channel the file channel to write the header to
     * @param locale the locale identifier to include in the header
     * @throws IOException if an I/O error occurs while writing to the channel
     */
    private void writeHeader(FileChannel channel, String locale) throws IOException {
        ByteBuffer buffer = ByteBuffer.allocate(8 + locale.length()).order(BYTE_ORDER);
        
        // Magic number
        buffer.put(MAGIC);
        
        // Version
        buffer.putShort(VERSION);
        
        // Locale length and string
        byte[] localeBytes = locale.getBytes("UTF-8");
        buffer.putShort((short) localeBytes.length);
        buffer.put(localeBytes);
        
        buffer.flip();
        channel.write(buffer);
    }
    
    /**
     * Writes the entries from the provided TranslationData to the specified FileChannel.
     *
     * @param channel the FileChannel to which the entries are written
     * @param data the TranslationData containing translation entries to be written
     * @throws IOException if an I/O error occurs while writing to the channel
     */
    private void writeEntries(FileChannel channel, TranslationData data) throws IOException {
        Map<String, TranslationEntry> entries = data.getEntries();
        
        // Write entry count
        ByteBuffer countBuffer = ByteBuffer.allocate(4).order(BYTE_ORDER);
        countBuffer.putInt(entries.size());
        countBuffer.flip();
        channel.write(countBuffer);
        
        // Write each entry
        for (Map.Entry<String, TranslationEntry> entry : entries.entrySet()) {
            writeEntry(channel, entry.getKey(), entry.getValue());
        }
    }
    
    /**
     * Writes a single translation entry to the provided file channel.
     *
     * @param channel The {@link FileChannel} to which the entry will be written.
     * @param hash The hash representing the translation entry's key.
     * @param entry The {@link TranslationEntry} containing the translation data to be written.
     * @throws IOException If an I/O error occurs during the write operation.
     */
    private void writeEntry(FileChannel channel, String hash, TranslationEntry entry) throws IOException {
        String translation = entry.getTranslation();
        if (translation == null) {
            translation = ""; // Empty string for untranslated entries
        }
        
        byte[] hashBytes = hash.getBytes("UTF-8");
        byte[] translationBytes = translation.getBytes("UTF-8");
        
        // Calculate buffer size: hash length (2) + hash + translation length (4) + translation
        int bufferSize = 2 + hashBytes.length + 4 + translationBytes.length;
        ByteBuffer buffer = ByteBuffer.allocate(bufferSize).order(BYTE_ORDER);
        
        // Hash length and string
        buffer.putShort((short) hashBytes.length);
        buffer.put(hashBytes);
        
        // Translation length and string
        buffer.putInt(translationBytes.length);
        buffer.put(translationBytes);
        
        buffer.flip();
        channel.write(buffer);
    }
    
    /**
     * Returns the output format handled by this writer.
     *
     * @return the output format, which in this case is {@code OutputFormat.BINARY}.
     */
    @Override
    public OutputFormat getOutputFormat() {
        return OutputFormat.BINARY;
    }
}