package io.github.unattendedflight.fluent.i18n.core;

import io.github.unattendedflight.fluent.i18n.util.IcuPluralExtractor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 * Builder for handling pluralization with natural text
 */
public class PluralBuilder {
    private final Number count;
    private final Locale locale;
    private final NaturalTextMessageSource messageSource;
    private final HashGenerator hashGenerator;
    private final Map<PluralForm, String> forms = new HashMap<>();
    private final IcuPluralExtractor extractor = new IcuPluralExtractor();
    
    public PluralBuilder(Number count, Locale locale, 
                        NaturalTextMessageSource messageSource, 
                        HashGenerator hashGenerator) {
        this.count = count;
        this.locale = locale;
        this.messageSource = messageSource;
        this.hashGenerator = hashGenerator;
    }
    
    public PluralBuilder zero(String naturalText) {
        forms.put(PluralForm.ZERO, naturalText);
        return this;
    }
    
    public PluralBuilder one(String naturalText) {
        forms.put(PluralForm.ONE, naturalText);
        return this;
    }
    
    public PluralBuilder two(String naturalText) {
        forms.put(PluralForm.TWO, naturalText);
        return this;
    }
    
    public PluralBuilder few(String naturalText) {
        forms.put(PluralForm.FEW, naturalText);
        return this;
    }
    
    public PluralBuilder many(String naturalText) {
        forms.put(PluralForm.MANY, naturalText);
        return this;
    }
    
    public PluralBuilder other(String naturalText) {
        forms.put(PluralForm.OTHER, naturalText);
        return this;
    }
    
    /**
     * Format the appropriate plural form
     */
    public String format() {
        PluralForm form = PluralRules.determine(count, locale);
        String naturalText = forms.getOrDefault(form, forms.get(PluralForm.OTHER));
        
        if (naturalText == null) {
            return String.valueOf(count);
        }
        
        // Generate the complete ICU MessageFormat string
        String icuPluralFormat = generateIcuPluralFormat();
        
        // Generate hash from the complete ICU MessageFormat string
        String hash = hashGenerator.generateHash(icuPluralFormat);
        
        // Try to get translation
        String result = naturalText;
        if (messageSource != null) {
            TranslationResult translation = messageSource.resolve(hash, naturalText, locale);
            result = translation.getTranslation();
            
            // If the translation is an ICU format string, parse it to extract the appropriate form
            if (result.startsWith("{0, plural,")) {
                result = extractPluralFormFromIcu(result, form);
            }
        }
        
        // Replace placeholders
        return result.replace("{0}", String.valueOf(count))
                    .replace("{}", String.valueOf(count))
                    .replace("#", String.valueOf(count));
    }
    
    /**
     * Generate the complete ICU MessageFormat string from all plural forms
     * This should match the format generated by the extractor for consistent hash generation
     */
    private String generateIcuPluralFormat() {
        StringBuilder sb = new StringBuilder("{0, plural, ");
        
        // Add all available forms in the order they were added
        boolean first = true;
        List<Map.Entry<PluralForm, String>> sortedForms = new ArrayList<>(forms.entrySet());
        // Force sort so zero, one, two, few, many, other are always in the same order
        sortedForms.sort((s1, s2) -> {
            int index1 = PluralForm.valueOf(s1.getKey().name()).ordinal();
            int index2 = PluralForm.valueOf(s2.getKey().name()).ordinal();
            return Integer.compare(index1, index2);
        });
        for (Map.Entry<PluralForm, String> entry : sortedForms) {
            // Skip null or empty forms
            if (entry.getValue() == null || entry.getValue().isEmpty()) {
                continue;
            }
            if (!first) {
                sb.append(" ");
            }
            sb.append(entry.getKey().name().toLowerCase())
              .append(" {")
              .append(entry.getValue())
              .append("}");
            first = false;
        }
        
        sb.append("}");
        return sb.toString();
    }
    
    /**
     * Extract the appropriate plural form from an ICU format string
     */
    private String extractPluralFormFromIcu(String icuString, PluralForm targetForm) {
        try {
            Map<PluralForm, String> icuForms = extractor.extractAllPluralForms(icuString);
            return icuForms.getOrDefault(targetForm, icuForms.getOrDefault(PluralForm.OTHER, String.valueOf(count)));

        } catch (Exception e) {
            // If parsing fails, fallback to original natural text
            return forms.getOrDefault(targetForm, forms.getOrDefault(PluralForm.OTHER, String.valueOf(count)));
        }
    }
    
    /**
     * Find the closing brace for a nested ICU format
     */
    private int findClosingBrace(String text, int start) {
        int braceCount = 0;
        for (int i = start; i < text.length(); i++) {
            char c = text.charAt(i);
            if (c == '{') {
                braceCount++;
            } else if (c == '}') {
                braceCount--;
                if (braceCount == 0) {
                    return i;
                }
            }
        }
        return -1;
    }
}